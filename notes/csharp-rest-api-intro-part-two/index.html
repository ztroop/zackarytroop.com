<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="Summary This is the second part of the REST Web API Introduction in C# series. If you haven&amp;rsquo;t already, check out Part One!
Prerequisites Please make sure you have docker and docker-compose installed.
Demonstration Continued In the Part One, we built the majority of our application. It should be functional at this point, but unrealistic in a production environment. We ideally wouldn&amp;rsquo;t be using an in-memory database, let&amp;rsquo;s change that."><meta name=keywords content="portfolio"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://zackarytroop.com/notes/csharp-rest-api-intro-part-two/><title>REST Web API Introduction in C# - Part Two :: Zackary Troop â€” Portfolio</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/main.4e5c639214707eff609bb55fe49e183dee42258a73bc90e4cc7b0a84f900798a.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="REST Web API Introduction in C# - Part Two"><meta itemprop=description content="Summary This is the second part of the REST Web API Introduction in C# series. If you haven&rsquo;t already, check out Part One!
Prerequisites Please make sure you have docker and docker-compose installed.
Demonstration Continued In the Part One, we built the majority of our application. It should be functional at this point, but unrealistic in a production environment. We ideally wouldn&rsquo;t be using an in-memory database, let&rsquo;s change that."><meta itemprop=datePublished content="2020-11-23T00:00:00+00:00"><meta itemprop=dateModified content="2020-11-23T00:00:00+00:00"><meta itemprop=wordCount content="768"><meta itemprop=image content="https://zackarytroop.com"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zackarytroop.com"><meta name=twitter:title content="REST Web API Introduction in C# - Part Two"><meta name=twitter:description content="Summary This is the second part of the REST Web API Introduction in C# series. If you haven&rsquo;t already, check out Part One!
Prerequisites Please make sure you have docker and docker-compose installed.
Demonstration Continued In the Part One, we built the majority of our application. It should be functional at this point, but unrealistic in a production environment. We ideally wouldn&rsquo;t be using an in-memory database, let&rsquo;s change that."><meta property="og:title" content="REST Web API Introduction in C# - Part Two"><meta property="og:description" content="Summary This is the second part of the REST Web API Introduction in C# series. If you haven&rsquo;t already, check out Part One!
Prerequisites Please make sure you have docker and docker-compose installed.
Demonstration Continued In the Part One, we built the majority of our application. It should be functional at this point, but unrealistic in a production environment. We ideally wouldn&rsquo;t be using an in-memory database, let&rsquo;s change that."><meta property="og:type" content="article"><meta property="og:url" content="https://zackarytroop.com/notes/csharp-rest-api-intro-part-two/"><meta property="og:image" content="https://zackarytroop.com"><meta property="article:section" content="notes"><meta property="article:published_time" content="2020-11-23T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-23T00:00:00+00:00"><meta property="og:site_name" content="Zackary Troop"><meta property="article:published_time" content="2020-11-23 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>ztroop</span>
<span class=logo__cursor style=background-color:#a9a9b3></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/notes>Notes</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://zackarytroop.com/notes/csharp-rest-api-intro-part-two/>REST Web API Introduction in C# - Part Two</a></h2><div class=post-content><h1 id=summary>Summary</h1><p>This is the second part of the <strong>REST Web API Introduction in C#</strong> series. If you haven&rsquo;t already,
check out <a href=@/notes/csharprestapi-1.md>Part One</a>!</p><h1 id=prerequisites>Prerequisites</h1><p>Please make sure you have <a href=https://docs.docker.com/get-docker/>docker</a> and <a href=https://docs.docker.com/compose/install/>docker-compose</a> installed.</p><h1 id=demonstration-continued>Demonstration Continued</h1><p>In the <strong>Part One</strong>, we built the majority of our application. It should be functional at this point,
but unrealistic in a production environment. We ideally wouldn&rsquo;t be using an in-memory database, let&rsquo;s change that.</p><h2 id=switching-databases>Switching Databases</h2><p>In the <code>Startup</code> constructor, in the <code>Startup.cs</code> file, we load configuration from <code>appsettings.json</code>.
We haven&rsquo;t created that yet, so let&rsquo;s do that and add the snippet below. We&rsquo;ll use that to load connection
details to our database.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;ConnectionStrings&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;DefaultConnection&#34;</span>: <span style=color:#e6db74>&#34;Server=db\\SQLEXPRESS,1433;Database=master;User ID=sa;Password=CHANGEME123!;Integrated Security=False;&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;re specifying a remote connection to a host known as <code>db</code>, which will resolve to an IP address. The reason
for this will become clearer as we complete our <code>docker</code> setup. <code>1433</code> is the port. The database itself will be an instance of Microsoft SQL Express.
The database name is <code>master</code>, with a user <code>sa</code> and password <code>CHANGEME123!</code>. We also set integrated security to <code>False</code> because
we <em>do</em> want to use our specified credentials.</p><blockquote><p>Integrated Security When false, User ID and Password are specified in the connection. When true, the current Windows account credentials are used for authentication. Recognized values are true, false, yes, no, and sspi (strongly recommended), which is equivalent to true. If User ID and Password are specified and Integrated Security is set to true, the User ID and Password will be ignored and Integrated Security will be used.</p></blockquote><p>See <a href="https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection.connectionstring?redirectedfrom=MSDN&view=dotnet-plat-ext-5.0#System_Data_SqlClient_SqlConnection_ConnectionString">SqlConnection.ConnectionString</a> for more information.</p><hr><p>In the same file, under <code>ConfigureServices</code>, we&rsquo;ll replace the line:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>services.AddDbContext&lt;DemoDbContext&gt;(opt =&gt; opt.UseInMemoryDatabase(databaseName: <span style=color:#e6db74>&#34;InMemoryDb&#34;</span>));
</span></span></code></pre></div><p>With the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>string</span> connectionString = Configuration.GetConnectionString(<span style=color:#e6db74>&#34;DefaultConnection&#34;</span>);
</span></span><span style=display:flex><span>services.AddDbContext&lt;DemoDbContext&gt;(opt =&gt; opt.UseSqlServer(connectionString));
</span></span></code></pre></div><p>Now we&rsquo;re pulling the database connection string from the <code>appsettings.json</code> file.
In a real environment, you might have different modes of operation (development, staging, production) where you&rsquo;d want to specify different database connections.</p><h2 id=docker>Docker</h2><p>In the previous step, we specified a SQL Express database connection. As we add more architectural components and services to our project, it becomes more complicated to deploy or on-board for new developers. <a href=https://docs.docker.com/>Docker</a> solves this problem.</p><h4 id=virtues-in-a-nutshell>Virtues in a Nutshell</h4><ol><li>Docker enables efficient use of system resources.</li><li>Docker enables faster software delivery cycles.</li><li>Docker enables application portability.</li></ol><p>Let&rsquo;s start by creating a <code>Dockerfile</code> in the parent directory of <code>CSharpRESTDemo</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> mcr.microsoft.com/dotnet/core/sdk:3.1 AS build</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Copy .csproj and restore as distinct layers.</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> CSharpRESTDemo/*.csproj ./CSharpRESTDemo/<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Restore dependencies specified in .csproj</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet restore CSharpRESTDemo<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Install the dotnet-ef tool.</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet tool install --global dotnet-ef<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Copy everything else and build app.</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> CSharpRESTDemo/. ./CSharpRESTDemo/<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> ./start.sh ./CSharpRESTDemo/<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app/CSharpRESTDemo</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> chmod +x ./start.sh<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Execute script when container runs.</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> /bin/bash ./start.sh<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li><code>start.sh</code> does not exist yet, we&rsquo;ll get to that in the next step.</li></ul><p>In this code snippet, we&rsquo;re using a microsoft image with correct dotnet version installed.
We copy over the <code>CSharpRESTDemo.csproj</code> file, and install the dependencies specified. We also install the
<code>dotnet-ef</code> tool so we can use the <strong>EntityFramework</strong> commands.</p><p>Next, we&rsquo;ll copy over the <code>CSharpRESTDemo</code> contents into the container.
Then, copying over the <code>start.sh</code> and mark it as executable. We&rsquo;ll use this to start up our application.</p><hr><p>Now we&rsquo;ll create a new file called <code>start.sh</code>, it should be in the parent directory of <code>CSharpRESTDemo</code> with the <code>Dockerfile</code>.
It should have the following contents:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>PATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$PATH<span style=color:#e6db74>:</span>$HOME<span style=color:#e6db74>/.dotnet/tools/&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>set -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>until</span> dotnet ef database update; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>&gt;&amp;<span style=color:#ae81ff>2</span> echo <span style=color:#e6db74>&#34;SQL Server is starting up&#34;</span>
</span></span><span style=display:flex><span>sleep <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt;&amp;<span style=color:#ae81ff>2</span> echo <span style=color:#e6db74>&#34;SQL Server is up - executing command&#34;</span>
</span></span><span style=display:flex><span>exec dotnet run
</span></span></code></pre></div><p>This script will attempt to perform database migrations (if needed) and run the application.</p><hr><p>The next step will allow us to compose our service components. Create a file in the parent drectory of <code>CSharpRESTDemo</code> called <code>docker-compose.yml</code>, it should have the following contents:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>api</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>.</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;5000:5000&#34;</span>
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;5001:5001&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>ASPNETCORE_URLS</span>: <span style=color:#e6db74>&#34;http://0.0.0.0:5000;https://0.0.0.0:5001&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>db</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#e6db74>&#34;mcr.microsoft.com/mssql/server:latest&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>SA_PASSWORD</span>: <span style=color:#e6db74>&#34;CHANGEME123!&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>ACCEPT_EULA</span>: <span style=color:#e6db74>&#34;Y&#34;</span>
</span></span></code></pre></div><p>In this file, we have <em>two</em> services, <code>api</code> and <code>db</code>.</p><p>Looking at <code>api</code>, we tell it to build the <code>Dockerfile</code> we created earlier and
make the port range <code>5000</code>-<code>5001</code> accessible to the host. We also specify an environment variable to tell the application runtime
that we want <code>kestrel</code> to bind to the ports we specified.</p><p>The <code>db</code> service will use a <em>ready-to-go</em> <a href=https://hub.docker.com/_/microsoft-mssql-server>Microsoft SQL Server</a>. We only need to specify <code>SA_PASSWORD</code> and <code>ACCEPT_EULA</code>. Note that
these are the same credentials we specified in the <code>appsettings.json</code> file earlier.</p><hr><p>Now you should be able to run <code>docker-compose up</code> and access the API on <code>http://localhost:5000</code>!</p><p>Check out the <strong>Part Three</strong> for more!</p></div></article><hr><div class=post-info></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.bb2c6bc3ed452ca4759660e4020811f248bc2320081559e8a32d8b0092773852941133639d35e8370d03d3ddaa750b1edd6b343c5bd22a55d5bdeae8f648f49b.js integrity="sha512-uyxrw+1FLKR1lmDkAggR8ki8IyAIFVnooy2LAJJ3OFKUETNjnTXoNw0D092qdQse3Ws0PFvSKlXVvero9kj0mw=="></script></body></html>